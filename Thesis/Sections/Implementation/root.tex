\section{ROOT}
ROOT is an open-source data analysis framework used by high energy physics. It can do fast data manipulation, save and access data, 
create graphics for publication, and even combine with high level languanges such as R and Python.


\subsection*{RDataFrame}
RDataFrame's main purpose is to make reading and handling of ROOT files easier, especially in 
relation to modern machine learning tools and their respective frameworks and environments. 
This is done by creating a dataframe type of structure of the ROOT n-tuples, and then 
lazily\footnote{In this context lazily means that the functions and or cuts are done first after 
all have been registered, see \href{https://root.cern/doc/master/classROOT_1_1RDataFrame.html}{ROOT 
guidelines} for more.} apply contraints to the data. Using PyROOT
\footnote{\href{https://root.cern/manual/python/}{PyROOT website}}, RDataFrame can be accessed in 
Python, as the functionality is wrapped around a C++ class. Below is a code example of how
to create a RDataFrame object, apply a cut and then create a column for later use. Here, good 
leptons are defined first, denoted as "ele\_SG" and "muo\_SG". A cut is then applied where we 
require that the number of good leptons is always 3. Finally, a column is created where the 
combination of type of leptons in the 3 lepton system is stored, as well as creating a histogram 
containing the results for that given channel\footnote{A channel here refers to a certain decay 
channel. The simulations of the SM is divided into several channels, and some look more alike than others. One example is 
the Higgs decay channel, with possible decays such as two photons, W bosons or Z bosons. This pertains 
to simulated events only, as we cannot control what decay channels we get in the data recorded at ATLAS} 
k. Notice here that if the variable already exists as a column in the dataframe, arithmetic and logic 
can be applied directly using those columns to create new one. More complicated variables, such as 
the flavor combination for the leptons, or the invariant mass of two particles must be found or 
calculated using C++ functions. An example of such a C++ function is shown below the python code example. 

\begin{figure}[H]
    \centering
\begin{lstlisting}[language=Python, style=pythonstyle, label={code:python_func_example}]
import ROOT as R

R.EnableImplicitMT(200)
R.gROOT.ProcessLine(".L helperFunctions.cxx+")
R.gSystem.AddDynamicPath(str(dynamic_path))
R.gInterpreter.Declare(
    '#include "helperFunctions.h"'
)  # Header with the definition of the myFilter function
R.gSystem.Load("helperFunctions_cxx.so")  # Library with the myFilter function

df_mc = getDataFrames(mypath_mc)
df_data = getDataFrames(mypath_data)
df = {**df_mc, **df_data}

for k in df.keys():

    # Signal leptons
    df[k] = df[k].Define(
        "ele_SG",
        "ele_BL && lepIsoLoose_VarRad && lepTight && (lepD0Sig <= 5 && lepD0Sig >= -5)",
    )  
    df[k] = df[k].Define(
        "muo_SG",
        "muo_BL && lepIsoLoose_VarRad && (lepD0Sig <= 3 && lepD0Sig >= -3)",
    )  
    df[k] = df[k].Define("isGoodLep", "ele_SG || muo_SG")
    df[k] = df[k].Define(
                "nlep_SG", "ROOT::VecOps::Sum(ele_SG)+ROOT::VecOps::Sum(muo_SG)"
            )

    df[k] = df[k].Filter("nlep_SG == 3", "3 SG leptons")

    # Define flavor combination based on 
    df[k] = df[k].Define("flcomp", "flavourComp3L(lepFlavor[ele_SG || muo_SG])")
    histo[f"flcomp_{k}" ] = df[k].Histo1D(
        (
            f"h_flcomp_{k}",
            f"h_flcomp_{k}",
            len(fldic.keys()),
            0,
            len(fldic.keys()),
        ),
        "flcomp",
        "wgt_SG",
    )
    \end{lstlisting}
    \caption[RDataFrame code example]{Example of event selection done using RDataFrame.}
    \label{code:rdata}
\end{figure}

In the code example above we see how RDataframe can be used for event selection. Line 1-9 are settings for ROOT, 
number of threads to use in the paralellization, extra helper functions written in C++ with .h and .so files and the path to the folder.
Lines 11-13 create a dictionary containing the ROOT RDataFrames used for event selection. These are categorized by channel name. 
The loop on line 15 does event selection for each channel sample, defining new variables in the RDataFrame, applying filters and creating histograms.
Some variables are constructed using variables already in the ROOT files such as energy and mass. Through custom C++ functions
these properties can be added to the RDataFrames. The example below shows a custom C++ function which is used in work of this thesis.

\begin{figure}[H]
    \centering
\begin{lstlisting}[language=C++, style=cppstyle, label={code:cpp_func_example}]
double getM(VecF_t &pt_i, VecF_t &eta_i, VecF_t &phi_i, VecF_t &e_i,
            VecF_t &pt_j, VecF_t &eta_j, VecF_t &phi_j, VecF_t &e_j,
            int i, int j)
{
    /* Gets he invariant mass between two particles, be it jets or leptons */

    const auto size_i = int(pt_i.size());
    const auto size_j = int(pt_j.size());

    if (size_i == 0 || size_j == 0){return 0.;}
    if (i > size_i-1){return 0.;}
    if (j > size_j-1){return 0.;}

    TLorentzVector p1;
    TLorentzVector p2;

    p1.SetPtEtaPhiM(pt_i[i], eta_i[i], phi_i[i], e_i[i]);
    p2.SetPtEtaPhiM(pt_j[j], eta_j[j], phi_j[j], e_j[j]);

    double inv_mass = (p1 + p2).M();

    return inv_mass;
}
\end{lstlisting}
\caption[C++ function example]{Example of a C++ function used in event selection.}
\end{figure}
This C++ function creates Lorentz vectors for two particles, and then returns the invariant mass based on the parameters sent in. 
This function will be used on all the leptons in a given event. If one particle or both do not exist, the C++ function will
return zero as the invariant mass. \par


\begin{figure}[H]
    \centering
\begin{lstlisting}[language=Python, style=pythonstyle, label={code:python_func_example_2}]
import pandas as pd 

cols = df.keys()

for k in cols:

    print(f"Transforming {k}.ROOT to numpy")
    numpy = df[k].AsNumpy(DATAFRAME_COLS)
    print(f"Numpy conversion done for {k}.ROOT")
    df1 = pd.DataFrame(data=numpy)
    print(f"Transformation done")
    

    df1.to_hdf(
        PATH_TO_STORE + f"/{k}_3lep_df_forML_bkg_signal_fromRDF.hdf5", "mini"
    )

\end{lstlisting}
\caption[Conversion from RDataFrame to NumPy]{Loop converting RDataFrames to NumPy structures, before being stored as HDF5 files.}
\end{figure}

Once event selection is done, the features have been chosen and histograms have been 
drawn, the RdataFrame can be converted to a Pandas dataframe. This is a very popular 
choice for data structure when doing data analysis in python. This is done through an 
intermediary step of converting the RDataframe to a numpy filestructure, which then can 
be converted to a Pandas\cite{reback2020pandas} dataframe or some other framework.
The new Pandas dataframes are stored as HDF5\cite{hdf5} files to be used later. This is 
because the HDF5 format has a very good compression ratio, and is very fast to read and write. 