\section{ROOT}

\subsection*{N tuples}

The main datastructure of ROOT is the so called N tuple structure. This datastructure contains each property for each type of particle in a given event, yeilding
a ragged structure. 

\begin{table}[H]
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \cline{1-5} \cline{7-7}
        & $jetP_T$      & $jetPhi$     & $lepP_T$             & $lepPhi$             &  & Rowlength \\ \cline{1-5} \cline{7-7} 
    $0$ & $[120.2, 57]$ & $[1.2, 0.5]$ & $[223.3, 57.5, 9.7]$ & $[0.545, 0.2, -0.3]$ &  & 10        \\ \cline{1-5} \cline{7-7} 
    $1$ & $[, ]$          & $[, ]$         & $[121.343, 89.323]$  & $[0.886, -0.855]$    &  & 4         \\ \cline{1-5} \cline{7-7} 
    $2$ & $[86.112]$    & $[86.112]$   & $[57.75, 34.5]$      & $[0.33, 0.255]$      &  & 6         \\ \cline{1-5} \cline{7-7} 
    \end{tabular}
\end{table}

\subsection*{RDataFrame}

\cite{Manca:2694107}

RDataFrame's main purpose is to make reading and handling of root files easier, especially in relation to modern machine learning tools and their 
respective frameworks and environments. This is done by creating a dataframe like structure of the root n-tuples, and then 
lazily\footnote{In this context lazily means that the functions and or cuts are done first after all have been registered, see \href{https://root.cern/doc/master/classROOT_1_1RDataFrame.html}{ROOT guidelines} for more.} 
apply contraints to the data. Using PyROOT, RDataFrame can be accessed in Python, as the functionality is wrapped around a C++ class. Below is an example of how
to create a RDataFrame object, apply a cut and then create a column for later use. Here, good leptons are defined first, denoted as "ele\_SG" and "muo\_SG". 
A cut is then applied where we require that the number of good leptons is always 3. Finally, a column is created where the combination of type of leptons 
in the 3 lepton system is stored, as well as creating a histogram containing the results for that given channel\footnote{A channel here refers to a certain decay channel. The standard model has several, and some look more alike than others. One example is the Higgs decay channel, with possible decays such as two photons, W bosons or Z bosons. } 
k. Notice here that if the variable already exist as a column in the dataframe, arithmetic and logic can be applied directly using those 
columns to create new one. More complicated variables, such as the flavor combination for the leptons, or the invariant mass of two particles must be 
found or calculated using C++ functions. An example of such a function is shown below the python code listing. 

\begin{figure}[H]
    \centering
\begin{lstlisting}[language=Python, style=pythonstyle, label={code:python_func_example}]
import ROOT as R

R.EnableImplicitMT(200)
R.gROOT.ProcessLine(".L helperFunctions.cxx+")
R.gSystem.AddDynamicPath(str(dynamic_path))
R.gInterpreter.Declare(
    '#include "helperFunctions.h"'
)  # Header with the definition of the myFilter function
R.gSystem.Load("helperFunctions_cxx.so")  # Library with the myFilter function

df_mc = getDataFrames(mypath_mc)
df_data = getDataFrames(mypath_data)
df = {**df_mc, **df_data}

for k in df.keys():

    # Signal leptons
    df[k] = df[k].Define(
        "ele_SG",
        "ele_BL && lepIsoLoose_VarRad && lepTight && (lepD0Sig <= 5 && lepD0Sig >= -5)",
    )  
    df[k] = df[k].Define(
        "muo_SG",
        "muo_BL && lepIsoLoose_VarRad && (lepD0Sig <= 3 && lepD0Sig >= -3)",
    )  
    df[k] = df[k].Define("isGoodLep", "ele_SG || muo_SG")
    df[k] = df[k].Define(
                "nlep_SG", "ROOT::VecOps::Sum(ele_SG)+ROOT::VecOps::Sum(muo_SG)"
            )

    df[k] = df[k].Filter("nlep_SG == 3", "3 SG leptons")

    # Define flavor combination based on 
    df[k] = df[k].Define("flcomp", "flavourComp3L(lepFlavor[ele_SG || muo_SG])")
    histo[f"flcomp_{k}" ] = df[k].Histo1D(
        (
            f"h_flcomp_{k}",
            f"h_flcomp_{k}",
            len(fldic.keys()),
            0,
            len(fldic.keys()),
        ),
        "flcomp",
        "wgt_SG",
    )
    \end{lstlisting}
\end{figure}

In the code listing above we see an example of how RDataframe can be used for event selection. Line 1-9 are settings for ROOT, 
how many threads to use in the parallellization, extra helper functions written in C++ with .h and .so files and the path to the folder.
The nex three lines creates a dictionary containing the ROOT RDataFrames to do event selection on. These are categorized by channel name. 
The loop then does event selection for each channel sample, defining new variables in the RDataFrame, applying filters, and creating histograms.
Some variables are constructed using variables already in the ROOT files, such as energy and mass and so on, which through custom C++ functions
can be added. In the codelisting below we see a custom C++ function which is used in this thesis.

\begin{figure}[H]
    \centering
\begin{lstlisting}[language=C++, style=cppstyle, label={code:cpp_func_example}]
double getM(VecF_t &pt_i, VecF_t &eta_i, VecF_t &phi_i, VecF_t &e_i,
            VecF_t &pt_j, VecF_t &eta_j, VecF_t &phi_j, VecF_t &e_j,
            int i, int j)
{
    /* Gets he invariant mass between two particles, be it jets or leptons */

    const auto size_i = int(pt_i.size());
    const auto size_j = int(pt_j.size());

    if (size_i == 0 || size_j == 0){return 0.;}
    if (i > size_i-1){return 0.;}
    if (j > size_j-1){return 0.;}

    TLorentzVector p1;
    TLorentzVector p2;

    p1.SetPtEtaPhiM(pt_i[i], eta_i[i], phi_i[i], e_i[i]);
    p2.SetPtEtaPhiM(pt_j[j], eta_j[j], phi_j[j], e_j[j]);

    double inv_mass = (p1 + p2).M();

    return inv_mass;
}
\end{lstlisting}
\end{figure}
The C++ function listed above creates Lorentzvectors for two particles, and then constructs the invariant mass based on the parameters sent in. 
this function will be used on all the leptons in a given event, and in the case that one particle or both do not exist, the C++ function will
return 0 as the invariant mass. \par

\begin{figure}[H]
    \centering
\begin{lstlisting}[language=Python, style=pythonstyle, label={code:python_func_example_2}]
import pandas as pd 

cols = df.keys()

for k in cols:

    print(f"Transforming {k}.ROOT to numpy")
    numpy = df[k].AsNumpy(DATAFRAME_COLS)
    print(f"Numpy conversion done for {k}.ROOT")
    df1 = pd.DataFrame(data=numpy)
    print(f"Transformation done")
    

    df1.to_hdf(
        PATH_TO_STORE + f"/{k}_3lep_df_forML_bkg_signal_fromRDF.hdf5", "mini"
    )

\end{lstlisting}
\end{figure}

Once eventselection is done, the features have been chosen and histograms have been drawn, the Rdataframe can be converted to a pandas dataframe, which is a very popular choice
for data structure when doing data analysis in python. This is done through an intermediary step of converting the RDataframe to a numpy filestructure, which then can be converted
to a pandas\cite{reback2020pandas} dataframe, or some other framwork. Here the new pandas dataframe is stored as hdf5\cite{hdf5} files to be used later, as the hdf5 format 
has a very good compression ratio, and is very fast to read and write. 